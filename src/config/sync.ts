import { mkdir, readFile, writeFile } from "node:fs/promises";
import { dirname, join, resolve } from "node:path";
import { loadSharedToolConfig } from "./loader.js";
import { renderClaudeConfig } from "./mappings/claude-code.js";
import { renderCopilotInstructions } from "./mappings/copilot.js";
import { renderCodexConfig } from "./mappings/codex.js";
import { renderCursorRules } from "./mappings/cursor.js";

const MARKERS = {
  markdown: {
    begin: "<!-- xtctx:begin -->",
    end: "<!-- xtctx:end -->",
  },
  text: {
    begin: "# xtctx:begin",
    end: "# xtctx:end",
  },
} as const;

interface SyncTarget {
  path: string;
  content: string;
  markers: {
    begin: string;
    end: string;
  };
}

export interface SyncedFileResult {
  path: string;
  updated: boolean;
  created: boolean;
}

export interface SyncToolConfigResult {
  updated: number;
  created: number;
  unchanged: number;
  files: SyncedFileResult[];
}

export async function syncToolConfigs(projectPath?: string): Promise<SyncToolConfigResult> {
  const projectRoot = resolve(projectPath ?? process.cwd());
  const sharedConfig = await loadSharedToolConfig(projectRoot);

  const targets: SyncTarget[] = [
    {
      path: join(projectRoot, ".cursorrules"),
      content: renderCursorRules(sharedConfig),
      markers: MARKERS.text,
    },
    {
      path: join(projectRoot, "CLAUDE.md"),
      content: renderClaudeConfig(sharedConfig),
      markers: MARKERS.markdown,
    },
    {
      path: join(projectRoot, "AGENTS.md"),
      content: renderCodexConfig(sharedConfig),
      markers: MARKERS.markdown,
    },
    {
      path: join(projectRoot, ".github", "copilot-instructions.md"),
      content: renderCopilotInstructions(sharedConfig),
      markers: MARKERS.markdown,
    },
  ];

  const files: SyncedFileResult[] = [];

  for (const target of targets) {
    await mkdir(dirname(target.path), { recursive: true });

    const existing = await readUtf8IfExists(target.path);
    const next = existing
      ? upsertManagedSection(existing, target.content, target.markers)
      : renderManagedSection(target.content, target.markers);
    const shouldWrite = !existing || normalizeNewlines(existing) !== normalizeNewlines(next);

    if (shouldWrite) {
      await writeFile(target.path, next, "utf-8");
    }

    files.push({
      path: target.path,
      updated: shouldWrite,
      created: !existing,
    });
  }

  const updated = files.filter((file) => file.updated).length;
  const created = files.filter((file) => file.created).length;

  return {
    updated,
    created,
    unchanged: files.length - updated,
    files,
  };
}

function upsertManagedSection(
  existing: string,
  blockContent: string,
  markers: { begin: string; end: string },
): string {
  const normalized = normalizeNewlines(existing);
  const sectionPattern = new RegExp(
    `${escapeRegExp(markers.begin)}[\\s\\S]*?${escapeRegExp(markers.end)}\\n?`,
    "g",
  );
  const withoutManagedSection = normalized.replace(sectionPattern, "").trimEnd();
  const managedSection = renderManagedSection(blockContent, markers).trimEnd();

  if (withoutManagedSection.length === 0) {
    return `${managedSection}\n`;
  }

  return `${withoutManagedSection}\n\n${managedSection}\n`;
}

function renderManagedSection(
  blockContent: string,
  markers: { begin: string; end: string },
): string {
  return [markers.begin, "Generated by xtctx sync. Do not edit inside this block.", "", blockContent, markers.end, ""].join(
    "\n",
  );
}

function normalizeNewlines(input: string): string {
  return input.replace(/\r\n/g, "\n");
}

function escapeRegExp(value: string): string {
  return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

async function readUtf8IfExists(filePath: string): Promise<string | null> {
  try {
    return await readFile(filePath, "utf-8");
  } catch {
    return null;
  }
}
